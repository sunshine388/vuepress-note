import{_ as n,W as s,X as a,Y as e,Z as t,$ as p}from"./framework-d2dfa12e.js";const i="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img1.png",o="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img2.png",c="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img3.png",l="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img4.png",u="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img5.png",d="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img6.png",r="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img7.png",k="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img8.png",m="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img9.png",v="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img10.png",g="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img11.png",f="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img12.png",b="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img13.png",h="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img14.png",y="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img15.png",_="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img16.png",x="/vuepress-note/images/手写vue2源码/（二十五）diff算法-乱序比对/img17.png",w={},q=t("p",null,"diff 算法-乱序比对",-1),V=p('<h2 id="乱序比对" tabindex="-1"><a class="header-anchor" href="#乱序比对" aria-hidden="true">#</a> 乱序比对</h2><h3 id="前文回顾" tabindex="-1"><a class="header-anchor" href="#前文回顾" aria-hidden="true">#</a> 前文回顾</h3><p>之前两篇主要介绍了，在进行乱序比对前针对几种特殊情况的处理，以提升比对性能：</p><ol><li>一方有儿子，一方没有儿子；老的有儿子，新的没有儿子：直接将多余的老 dom 元素删除即可；老的没有儿子，新的有儿子：直接将新的儿子节点放入对应的老节点中即可；</li><li>新老节点都有儿子时，进行头头、尾尾、头尾、尾头对比；</li><li>头头、尾尾、头尾、尾头均没有命中时，进行乱序比对</li></ol><p>本篇主要介绍 diff 算法的乱序比对，目标是尽可能复用老节点，以提升渲染性能；</p><h3 id="乱序比对方案" tabindex="-1"><a class="header-anchor" href="#乱序比对方案" aria-hidden="true">#</a> 乱序比对方案</h3><p>这种情况下，头头、尾尾、头尾、尾头都不相同</p><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>理想情况下，A、B 节点是可以被复用的：</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>方案：</p><p>以新节点为主，以老节点做参照，</p><p>到老儿子集合中去找能复用的节点，再将不能复用老节点删掉；</p><p>创建一个映射关系：</p><p>根据老儿子集合创建一个节点 key 和索引 index 的映射关系 mapping，</p><p>用新节点依次到老的索引列表中查找是否存在，如果存在就复用；</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="乱序比对过程分析" tabindex="-1"><a class="header-anchor" href="#乱序比对过程分析" aria-hidden="true">#</a> 乱序比对过程分析</h3><p>1，先比对一下头头、尾尾、头尾、尾头，没有命中：</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查找 F 是否在映射关系中，不在，直接做插入操作：插入到老的头指针前面的位置</p><p>即：将 F 节点插入到 A 节点的前面，并将新的头指针向后移动：</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>2，再对比一下头头、尾尾、头尾、尾头，还是没有命中：</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>继续查找 B 是否在映射关系中，B 在映射关系中，复用 B 节点并做移动操作：将复用节点移动到头指针指向节点的前面</p><p>即：将老的 B 节点移动到 A 节点的前面，并将新的头指针向后移动：</p><p>备注：由于原来的 B 节点被移动走了，所以之前的空位置要做标记，后续指针移动至此直接跳过</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>3，继续比对一次头头、尾尾、头尾、尾头，这时发现头和头相同，命中了头头比对：</p><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这时，按照头头比对的逻辑：老的头指针向后移动，新头指针也向后移动；（同理，如果这里命中了尾尾比对，就将新老尾指针都向前进行移动；）</p><p>但由于之前 B 节点已经移动到 A 节点前面了，所以老的头指针跳过原始 B 节点位置，直接移动到 C 位置：</p><p>备注：这里就使用到了之前 B 节点移动走后所做的空位置标记；</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>4，继续比对一次头头、尾尾、头尾、尾头，没有命中：</p><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查找 E 是否在映射关系中，不在，直接做插入操作：插入到老的头指针前面的位置</p><p>即：将 E 节点插入到 C 节点的前面，并将新的头指针向后移动：</p><p>备注：永远是插入到老的头指针前面的位置</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>5，继续比对一次头头、尾尾、头尾、尾头，没有命中：</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查找 G 是否在映射关系中，不在，直接做插入操作：插入到老的头指针前面的位置 6，</p><p>即：将 G 节点插入到 C 节点的前面，并将新的头指针向后移动：</p><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>6，由于新儿子数组已全部比对完成，剩余的老节点直接删除即可，</p><p>依次删除“从老的头节点到老的尾节点”区域的全部节点：</p><figure><img src="'+h+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>所以，最终结果为 F B A E G；其中，A、B 节点实现了节点复用；</p><h2 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现" aria-hidden="true">#</a> 代码实现</h2><h3 id="新老节点更新示例" tabindex="-1"><a class="header-anchor" href="#新老节点更新示例" aria-hidden="true">#</a> 新老节点更新示例</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> render1 <span class="token operator">=</span> <span class="token function">compileToFunction</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">&lt;div&gt;
    &lt;li key=&quot;A&quot;&gt;A&lt;/li&gt;
    &lt;li key=&quot;B&quot;&gt;B&lt;/li&gt;
    &lt;li key=&quot;C&quot;&gt;C&lt;/li&gt;
    &lt;li key=&quot;D&quot;&gt;D&lt;/li&gt;
&lt;/div&gt;</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> render2 <span class="token operator">=</span> <span class="token function">compileToFunction</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">&lt;div&gt;
    &lt;li key=&quot;F&quot; style=&quot;color:pink&quot;&gt;F&lt;/li&gt;
    &lt;li key=&quot;B&quot; style=&quot;color:yellow&quot;&gt;B&lt;/li&gt;
    &lt;li key=&quot;A&quot; style=&quot;color:blue&quot;&gt;A&lt;/li&gt;
    &lt;li key=&quot;E&quot; style=&quot;color:red&quot;&gt;E&lt;/li&gt;
    &lt;li key=&quot;P&quot; style=&quot;color:red&quot;&gt;P&lt;/li&gt;
&lt;/div&gt;</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="创造映射关系" tabindex="-1"><a class="header-anchor" href="#创造映射关系" aria-hidden="true">#</a> 创造映射关系</h3><p>根据老儿子集合创建节点 key 与索引 index 的映射关系 mapping：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// src/vdom/patch.js#updateChildren#makeKeyByIndex</span>

<span class="token keyword">function</span> <span class="token function">updateChildren</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> oldChildren<span class="token punctuation">,</span> newChildren</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token doc-comment comment">/**
   * 根据children创建映射
   */</span>
  <span class="token keyword">function</span> <span class="token function">makeKeyByIndex</span><span class="token punctuation">(</span><span class="token parameter">children</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      map<span class="token punctuation">[</span>item<span class="token punctuation">.</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> index<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">debugger</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> map<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> mapping <span class="token operator">=</span> <span class="token function">makeKeyByIndex</span><span class="token punctuation">(</span>oldChildren<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试：</p><figure><img src="`+y+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="处理步骤" tabindex="-1"><a class="header-anchor" href="#处理步骤" aria-hidden="true">#</a> 处理步骤</h3><blockquote><p>筛查：看新节点在老的里面是否存在，到 mapping 中去筛查</p><p>没有，将当前比对的新节点插入到老的头指针对用的节点前面</p><p>有，需要复用，将当前比对的老节点移动到老的头指针前面</p><p>复用步骤：插入 dom、patch 更新属性，原位置置空，指针移动</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIndex <span class="token operator">&lt;=</span> oldEndIndex <span class="token operator">&amp;&amp;</span> newStartIndex <span class="token operator">&lt;=</span> newEndIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当前循环开始时，先处理当前的oldStartVnode和oldEndVnode为空的情况；</span>
  <span class="token comment">// 原因：节点之前被移走时置空，直接跳过</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>oldStartVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    oldStartVnode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>oldEndVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    oldEndVnode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSameVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 头头比较</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSameVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 尾尾比较</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSameVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 头尾比较</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSameVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 尾头比较</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 前面4种逻辑（头头、尾尾、头尾、尾头）,主要是考虑到用户使用时的一些特殊场景，但也有非特殊情况，如：乱序排序</span>
    <span class="token comment">// 筛查当前新的头指针对应的节点在mapping中是否存在</span>
    <span class="token keyword">let</span> moveIndex <span class="token operator">=</span> mapping<span class="token punctuation">[</span>newStartVnode<span class="token punctuation">.</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>moveIndex <span class="token operator">==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 没有，将当前比对的新节点插入到老的头指针对用的节点前面</span>
      <span class="token comment">// 将当前新的虚拟节点创建为真实节点，插入到老的开始节点前面</span>
      el<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span><span class="token function">createElm</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">)</span><span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 有,需要复用</span>
      <span class="token comment">// 将当前比对的老节点移动到老的头指针前面</span>
      <span class="token keyword">let</span> moveVnode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>moveIndex<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 从老的队列中找到可以被复用的这个节点</span>
      el<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>moveVnode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 复用：位置移动完成后，还要对比并更新属性</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>moveVnode<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 由于复用的节点在oldChildren中被移走了,之前的位置要标记为空(指针移动时，跳过会使用)</span>
      oldChildren<span class="token punctuation">[</span>moveIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 每次处理完成后，新节点的头指针都需要向后移动</span>
    <span class="token comment">// 备注：</span>
    <span class="token comment">//     无论节点是否可复用，新指针都会向后移动，所以最后统一处理；</span>
    <span class="token comment">//    节点可复用时，老节点的指针移动会在4种特殊情况中被处理完成；</span>
    newStartVnode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span><span class="token operator">++</span>newStartIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="删除多余的老节点" tabindex="-1"><a class="header-anchor" href="#删除多余的老节点" aria-hidden="true">#</a> 删除多余的老节点</h3><p>注意：由于在新旧节点的对比时，有可能已经将部分节点移动走了，移走时置为了 undefined</p><p>所以此时删除多余节点时，有可能这个新老指针的区间中包含这 undefined 的节点，需要跳过去</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 2，旧的多，（以旧指针为参照）删除多余的真实节点</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartIndex <span class="token operator">&lt;=</span> oldEndIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> oldStartIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> oldEndIndex<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> child <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// child有值时才删除；原因：节点有可能在移走时被置为undefined</span>
    child <span class="token operator">&amp;&amp;</span> el<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="测试乱序比对更新" tabindex="-1"><a class="header-anchor" href="#测试乱序比对更新" aria-hidden="true">#</a> 测试乱序比对更新</h3><p>更新前：</p><figure><img src="`+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>更新后：</p><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>节点更新情况：</p><blockquote><p>A 节点复用，只更新了颜色</p><p>F、E、G 均为新增节点</p><p>B 节点仅做了移动操作</p></blockquote><p>这样，就尽可能的复用了老节点；</p>',73);function B(S,E){return s(),a("div",null,[q,e(" more "),V])}const I=n(w,[["render",B],["__file","（二十五）diff算法-乱序比对.html.vue"]]);export{I as default};
