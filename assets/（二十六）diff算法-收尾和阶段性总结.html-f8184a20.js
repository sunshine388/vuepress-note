import{_ as e,W as p,X as t,Y as o,Z as n,$ as a,a0 as s}from"./framework-d2dfa12e.js";const c="/vuepress-note/images/手写vue2源码/（二十六）diff算法-收尾+阶段性总结/img1.png",l="/vuepress-note/images/手写vue2源码/（二十六）diff算法-收尾+阶段性总结/img2.png",i={},u=n("p",null,"diff 算法的阶段性梳理",-1),r=a(`<h2 id="初渲染与视图更新流程" tabindex="-1"><a class="header-anchor" href="#初渲染与视图更新流程" aria-hidden="true">#</a> 初渲染与视图更新流程</h2><ol><li>Vue 初渲染时，会调用 mountComponent 方法进行挂载，在 mountComponent 方法中，会创建一个 watcher；</li><li>当数据更新时，进入 Object.defineProperty 的 set 方法，在 set 方法中，会调用 dep.notify() 通知收集的 watcher 调用 update 方法做更新渲染；</li><li>在 Watcher 类的 update 方法中，调用了 queueWatcher 方法将 watcher 进行缓存、去重操作</li><li>queueWatcher 方法中调用 flushschedulerQueue 方法，执行所有 watcher.run 并清空队列</li><li>Watcher 类中的 run 方法，内部调用了 Watcher 类中的 get 方法：记录当前 watcher 并调用 getter</li><li>this.getter 是 Watcher 类实例化时传入的视图更新方法 fn，即 updateComponent 视图渲染逻辑</li><li>执行 updateComponent 中的 vm._render，使用最新数据重新生成虚拟节点并调用 update 更新视图</li></ol><h2 id="diff-算法的外层更新" tabindex="-1"><a class="header-anchor" href="#diff-算法的外层更新" aria-hidden="true">#</a> diff 算法的外层更新</h2><p>在 Vue 中，每次数据变化时，并不会对节点做全量的替换，而是会对新老虚拟节点进行 diff 比对：</p><blockquote><p>首次渲染，根据虚拟节点生成真实节点，替换掉原来的节点 更新渲染，生成新的虚拟节点，并与老的虚拟节点比对，复用老节点进行渲染</p></blockquote><p>diff 算法：</p><blockquote><p>又叫同层比对算法； 深度优先遍历递归； 采用了“头尾指针”的处理;通过对新老虚拟节点进行比对，尽可能复用原有节点，以提升渲染性能；</p></blockquote><p>节点可复用的依据：</p><blockquote><p>标签名和 key 均相同，即判定为可复用节点；</p></blockquote><p>patch 方法做节点的递归更新：通过 oldVnode.nodeType 节点类型，判断是否为真实节点；</p><blockquote><p>非真实节点，即为真实 dom 时，进行初渲染逻辑 是真实节点，需要进行新老虚拟节点比对</p></blockquote><p>新老虚拟节点比对：</p><blockquote><p>节点不相同时，使用新的真实节点：createElm(vnode)，替换老的真实节点：oldVnode.el；oldVnode.el.parentNode.replaceChild(createElm(vnode), oldVnode.el); 节点相同时，复用老节点，更新文本、样式等属性即可；</p></blockquote><p>文本的处理：</p><blockquote><p>文本节点没有标签名 文本节点没有有儿子</p></blockquote><p>元素的处理：</p><blockquote><p>新老元素都有的属性，用新值覆盖老值； 新的没有，老的有的属性，直接删除掉；</p></blockquote><p>style 的处理：</p><blockquote><p>老样式对象中有，新样式对象中没有，删掉多余样式； 新样式对象中有，覆盖到老样式对象中；</p></blockquote><h2 id="diff-算法的比对优化" tabindex="-1"><a class="header-anchor" href="#diff-算法的比对优化" aria-hidden="true">#</a> diff 算法的比对优化</h2><h3 id="新老儿子节点的情况" tabindex="-1"><a class="header-anchor" href="#新老儿子节点的情况" aria-hidden="true">#</a> 新老儿子节点的情况</h3><p>情况 1：老的有儿子，新的没有儿子 处理方法：直接将多余的老 dom 元素删除即可；</p><p>情况 2：老的没有儿子，新的有儿子 处理方法：直接将新的儿子节点放入对应的老节点中即可；</p><p>情况 3：新老都有儿子 处理方法：进行 diff 比对；</p><h3 id="新老儿子节点的-diff-比对" tabindex="-1"><a class="header-anchor" href="#新老儿子节点的-diff-比对" aria-hidden="true">#</a> 新老儿子节点的 diff 比对</h3><p>新老儿子节点的比对，采用了头尾双指针的方法; 新老节点都有儿子时，进行头头、尾尾、头尾、尾头对比； 头头、尾尾、头尾、尾头均没有命中时，进行乱序比对;</p><h2 id="diff-算法的乱序比对" tabindex="-1"><a class="header-anchor" href="#diff-算法的乱序比对" aria-hidden="true">#</a> diff 算法的乱序比对</h2><p>根据老儿子集合创建一个节点 key 和索引 index 的映射关系 mapping；用新儿子节点依次到 mapping 中查找是否存在可复用的节点； 存在复用节点，更新可复用节点属性并移动到对应位置；（移动走的老位置要做空标记） 不存在复用节点，创建节点并添加到对应位置； 最后，再将不可复用的老节点删除；</p><h2 id="diff-算法收尾" tabindex="-1"><a class="header-anchor" href="#diff-算法收尾" aria-hidden="true">#</a> diff 算法收尾</h2><h3 id="问题分析" tabindex="-1"><a class="header-anchor" href="#问题分析" aria-hidden="true">#</a> 问题分析</h3><p>至此，已经完成了 diff 算法的全部逻辑编写，但一直使用模拟新老节点更新; 原因在于，每次更新时都执行 patch(vm.$el, vnode)</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// src/lifecycle.js</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">lifeCycleMixin</span><span class="token punctuation">(</span><span class="token parameter">Vue</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">vnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token comment">// 传入当前真实元素vm.$el，虚拟节点vnode，返回新的真实元素</span>
    vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> <span class="token function">patch</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用两个虚拟节点模拟 diff 更新时，我们已经修改了 patch 方法：使之既能够支持初渲染，还能支持更新渲染：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// src/vdom/patch.js</span>

<span class="token doc-comment comment">/**
 * 将虚拟节点转为真实节点后插入到元素中
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span><span class="token operator">*</span><span class="token punctuation">}</span></span> <span class="token parameter">oldVnode</span>  老的虚拟节点
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span><span class="token operator">*</span><span class="token punctuation">}</span></span> <span class="token parameter">vnode</span>     新的虚拟节点
 * <span class="token keyword">@returns</span>             新的真实元素
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> vnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> isRealElement <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>nodeType<span class="token punctuation">;</span>  <span class="token comment">// 真实节点：1，虚拟节点：无此属性</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isRealElement<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 真实节点</span>
    <span class="token comment">// 1，根据虚拟节点创建真实节点</span>
    <span class="token keyword">const</span> elm <span class="token operator">=</span> <span class="token function">createElm</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2，使用真实节点替换掉老节点</span>
    <span class="token comment">// 找到元素的父亲节点</span>
    <span class="token keyword">const</span> parentNode <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>parentNode<span class="token punctuation">;</span>
    <span class="token comment">// 找到老节点的下一个兄弟节点（nextSibling 若不存在将返回 null）</span>
    <span class="token keyword">const</span> nextSibling <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>nextSibling<span class="token punctuation">;</span>
    <span class="token comment">// 将新节点 elm 插入到老节点el的下一个兄弟节点 nextSibling 的前面</span>
    <span class="token comment">// 备注：若 nextSibling 为 null，insertBefore 等价于 appendChild</span>
    parentNode<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> nextSibling<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 删除老节点 el</span>
    parentNode<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> elm<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// diff：新老虚拟节点比对</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isSameVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 同级比较，不是相同节点时，不考虑复用（放弃跨层复用），直接用新的替换旧的</span>
      <span class="token keyword">return</span> oldVnode<span class="token punctuation">.</span>el<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span><span class="token function">createElm</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">,</span> oldVnode<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 相同节点，就复用节点（复用老的），再更新不一样的地方（属性），注意文本要做特殊处理，文本是没有标签名的</span>

    <span class="token comment">// 文本的处理：文本直接更新就可以，因为文本没有儿子  组件中 Vue.component（‘xxx’）这就是组件的 tag</span>
    <span class="token keyword">let</span> el <span class="token operator">=</span> vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>el<span class="token punctuation">;</span>  <span class="token comment">// 节点复用：将老节点el，赋值给新节点el</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>oldVnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 文本：没有标签名</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 文本内容变化了，更新文本内容：用新的内容更新老的内容</span>
        <span class="token keyword">return</span> el<span class="token punctuation">.</span>textContent <span class="token operator">=</span> vnode<span class="token punctuation">.</span>text<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 元素的处理：相同节点，且新老节点不都是文本时</span>
    <span class="token function">updateProperties</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> oldVnode<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 比较儿子节点</span>
    <span class="token keyword">let</span> oldChildren <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>children <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> newChildren <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 情况 1：老的有儿子，新的没有儿子；直接把老的 dom 元素干掉即</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldChildren<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> newChildren<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">;</span><span class="token comment">//暴力写法直接清空；更好的处理是封装removeChildNodes方法：将子节点全部删掉，因为子节点可能包含组件</span>
      <span class="token comment">// 情况 2：老的没有儿子，新的有儿子；直接将新的插入即可</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldChildren<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> newChildren<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newChildren<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">child</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token comment">// 注意：这里的child是虚拟节点，需要变为真实节点</span>
        <span class="token keyword">let</span> childElm <span class="token operator">=</span> <span class="token function">createElm</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据新的虚拟节点，创建一个真实节点</span>
        el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>childElm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将生成的真实节点，放入 dom</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token comment">// 情况 3：新老都有儿子</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment">// 递归: updateChildren 内部调用 patch, patch, 内部还会调用 updateChildren (patch 方法是入口)</span>
      <span class="token function">updateChildren</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> oldChildren<span class="token punctuation">,</span> newChildren<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> el<span class="token punctuation">;</span><span class="token comment">// 返回新节点</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="正常使用方式" tabindex="-1"><a class="header-anchor" href="#正常使用方式" aria-hidden="true">#</a> 正常使用方式</h3><p>将模拟节点更新的代码全部注释掉，并修改 index.html</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> diff算法 <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 场景：div标签复用，仅更新span标签中的文本 name <span class="token operator">--</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;./vue.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">&quot;#app&quot;</span><span class="token punctuation">,</span>
      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;Brave&#39;</span> <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;BraveWang&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="测试修改前效果" tabindex="-1"><a class="header-anchor" href="#测试修改前效果" aria-hidden="true">#</a> 测试修改前效果</h3><p>测试 patch 方法修改前的效果： <img src="`+c+'" alt="" loading="lazy"></p>',39),d=n("p",null,[s("测试结果：将 div 标签全部干掉，重新创建了一次； 原因分析：每次都执行 vm."),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"e"),n("mi",null,"l"),n("mo",null,"="),n("mi",null,"p"),n("mi",null,"a"),n("mi",null,"t"),n("mi",null,"c"),n("mi",null,"h"),n("mo",{stretchy:"false"},"("),n("mi",null,"v"),n("mi",null,"m"),n("mi",{mathvariant:"normal"},".")]),n("annotation",{encoding:"application/x-tex"},"el = patch(vm.")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6944em"}}),n("span",{class:"mord mathnormal"},"e"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"="),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal"},"p"),n("span",{class:"mord mathnormal"},"a"),n("span",{class:"mord mathnormal"},"t"),n("span",{class:"mord mathnormal"},"c"),n("span",{class:"mord mathnormal"},"h"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),n("span",{class:"mord mathnormal"},"m"),n("span",{class:"mord"},".")])])]),s("el, vnode);，没有区分初渲染和更新渲染；")],-1),k=a(`<h3 id="如何区分初渲染和更新渲染" tabindex="-1"><a class="header-anchor" href="#如何区分初渲染和更新渲染" aria-hidden="true">#</a> 如何区分初渲染和更新渲染</h3><p>如何区分初渲染和更新渲染？</p><blockquote><p>第一次渲染时，在 vm.preVnode 上保存当前 Vnode； 第二次渲染时，先取 vm.preVnode，有值就是更新渲染； 初渲染，执行 patch(vm.$el, vnode)； 更新渲染，执行 patch(preVnode, vnode)；</p></blockquote><h3 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现" aria-hidden="true">#</a> 代码实现</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">lifeCycleMixin</span><span class="token punctuation">(</span><span class="token parameter">Vue</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">vnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token comment">// 取上一次的 preVnode</span>
    <span class="token keyword">let</span> preVnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>preVnode<span class="token punctuation">;</span>
    <span class="token comment">// 渲染前，先保存当前 vnode</span>
    vm<span class="token punctuation">.</span>preVnode <span class="token operator">=</span> vnode<span class="token punctuation">;</span>
    <span class="token comment">// preVnode 有值，说明已经有节点了，本次是更新渲染；没值就是初渲染</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>preVnode<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 初渲染</span>
      <span class="token comment">// 传入当前真实元素vm.$el，虚拟节点vnode，返回新的真实元素</span>
      vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> <span class="token function">patch</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment">// 更新渲染:新老虚拟节点做 diff 比对</span>
      vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> <span class="token function">patch</span><span class="token punctuation">(</span>preVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="测试修改后的效果" tabindex="-1"><a class="header-anchor" href="#测试修改后的效果" aria-hidden="true">#</a> 测试修改后的效果</h3><p>测试 patch 方法修改后的效果： <img src="`+l+'" alt="" loading="lazy"></p><p>测试结果：div 标签被复用，只更新了 span 中的 name；</p>',8);function m(v,h){return p(),t("div",null,[u,o(" more "),r,d,k])}const f=e(i,[["render",m],["__file","（二十六）diff算法-收尾和阶段性总结.html.vue"]]);export{f as default};
